use crate::na_ast::*;

grammar;

pub Nana: Nana = {
    <Expr> => <>.into(),
    <BlockInner> => <>.into(),
};

Expr: Expr = {
    <Atom> => <>.into(),
    <Application> => <>.into(),
};

Application: Application = {
    <func:Atom> <args:Atom+> => (func,args).into(),
};

Atom: Atom = {
    // Note: Now parentheses are dealt by single element tuple.
    // "(" <Expr> ")" => <>.into(), 
    <Block> => <>.into(),
    <Struct> => <>.into(),
    <Binder> => <>.into(), // Fixme: Binder.
    <Literal> => <>.into(),
};

Block: Block = {
    "[" <BlockInner> "]" => <>.into(),
};

BlockInner: Block = {
    <bs:Binding+> <v:Expr> => (bs, v).into(),
    <Binding+> => <>.into(),
};

Struct: Struct = {
    "[" <Comma<Expr>> "]" => Struct::Sequence(<>),
    "(" <Comma<Expr>> ")" => Struct::Tuple(<>),
};

Literal: Literal = {
    <INTCONST> => <>.into(),
    <FLTCONST> => <>.into(),
    <STRCONST> => <>.into(),
};

Binding: Binding = {
    <hs:Head+> <e:Expr> ";" => (hs,e).into(),
};

Binder: Binder = {
    <IDENT> => <>.into(),
    <UIDENT> => <>.into(),
    // <SYMBOLIDENT> => <>.into(),
};

// Note: Head is now guarded by "$" because of ambiguity.
Head: Head = {
    "$" <b:Binder> <ps:Pattern+> <m:Mask> => (b,ps,m).into(), // Fixme: Pattern+
    "$" <p:Pattern> <m:Mask> => (p,m).into(),
};

Mask: Mask = {
    "=" => Mask::Closed,
    ":=" => Mask::Exposed,
};

Pattern: Pattern = {
    <Binder> => Pattern::Binder(<>),
    <WILDCARD> => Pattern::Arbitrary,
    "<" <bs:SemiColonOnce<Binder>> ">" => Pattern::Exposure(bs.into()),
    "<" <EVERYTHING> ">" => Pattern::Exposure(ExposurePattern::All),
    "[" <ps:Comma<Pattern>> "]" => Pattern::Sequence(ps), // Fixme:Sequence
    "(" <ps:Comma<Pattern>> ")" => Pattern::Tuple(ps), // Fixme:Sequence
};




// Identifiers

IDENT: String = r"[a-zA-Z][_0-9a-zA-Z]*'*" => <>.into();
UIDENT: String = r"_[a-zA-Z][_0-9a-zA-Z]*'*" => <>.into();
WILDCARD: String = "_" => <>.into();
EVERYTHING: String = "*" => <>.into();
// SYMBOLIDENT: String = "(" <syn:r"-"> ")" => syn.into(); // Todo: [+-*/~!$%&]


// Const

INTCONST: u64 = {
    r"[0-9]+" => <>.parse::<u64>().unwrap(),
    // r"0[xX][0-9a-fA-F]+" => <>.parse::<u64>().unwrap(),
};
FLTCONST: f64 = {
    r"[0-9]*\.[0-9]+([eE][-\+]?[0-9]+)?" => <>.parse::<f64>().unwrap(),
    r"[0-9]+[eE][-\+]?[0-9]+" => <>.parse::<f64>().unwrap(),
};
STRCONST: String = r#""[^"]*""# => <>.into();

// Utility

#[inline]
Comma<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

#[inline]
CommaOnce<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T> => {
        v.push(e);
        v
    }
};

#[inline]
SemiColon<T>: Vec<T> = {
    <mut v:(<T> ";")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

#[inline]
SemiColonOnce<T>: Vec<T> = {
    <mut v:(<T> ";")*> <e:T> => {
        v.push(e);
        v
    }
};
