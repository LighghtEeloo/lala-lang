use crate::na_ast::*;

grammar;

pub Nana: Nana = {
    <Expr> => <>.into(),
};

Expr: Expr = {
    <Atom> => <>.into(),
    <Application> => <>.into(),
};

Atom: Atom = {
    <Block> => <>.into(),
    <Literal> => <>.into(),
};

Block: Block = {
    "[" <BlockInner> "]" => <>.into(),
};

BlockInner: Block = {
    <bs:Binding*> <v:Expr> => (bs, v).into(),
    <Binding*> => <>.into(),
};

Application: Application = {
    <b:Binder> => b.into(),
    <b:Binder> <ats:Atom+> => (b,ats).into(),
};

Literal: Literal = {
    // r#"".*""# => <>.to_owned().into(),
    r#""[^"]*""# => <>.to_owned().into(),
};

Binding: Binding = {
    <hs:Head+> <e:Expr> ";" => (hs,e).into(),
};

Binder: Binder = {
    <IDENT> => <>.into(),
    <UIDENT> => <>.into(),
    // <SYMBOLIDENT> => <>.into(),
};

Head: Head = {
    <b:Binder> <p:Pattern> <m:Mask> => (b,p,m).into(),
    <p:Pattern> <m:Mask> => (p,m).into(),
};

Mask: Mask = {
    "=" => Mask::Closed,
    ":=" => Mask::Exposed,
};

Pattern: Pattern = {
    <Binder> => Pattern::Binder(<>),
    <WILDCARD> => Pattern::Arbitrary,
    <EVERYTHING> => Pattern::Everything,
    "<" <bs:SemiColonOnce<Binder>> ">" => Pattern::Exposure(bs),
    // "[" <ps:CommaOnce<Pattern>> "]" => Pattern::Sequence(ps), // Todo: Seq pat
};




// Identifiers

IDENT: String = r"[a-zA-Z][_0-9a-zA-Z]*'*" => <>.into();
UIDENT: String = r"_[a-zA-Z][_0-9a-zA-Z]*'*" => <>.into();
WILDCARD: String = "_" => <>.into();
EVERYTHING: String = "*" => <>.into();
// SYMBOLIDENT: String = "(" <syn:r"-"> ")" => syn.into(); // Todo: [+-*/~!$%&]


// Const

// INTCONST: i32 = r"[+-]?[0-9]+" => i32::from_str(<>).unwrap();

// Utility

Comma<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

CommaOnce<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T> => {
        v.push(e);
        v
    }
};

SemiColon<T>: Vec<T> = {
    <mut v:(<T> ";")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

SemiColonOnce<T>: Vec<T> = {
    <mut v:(<T> ";")*> <e:T> => {
        v.push(e);
        v
    }
};
